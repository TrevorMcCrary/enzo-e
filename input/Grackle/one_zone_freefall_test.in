#
#  Grackle Test Problem:
#
#  Sets up a cooling test without hydrodynamics to run many
#  one-zone models in Grackle, fully sampling the density,
#  energy, and metallicity parameter space over which 
#  the chemistry and cooling/heating tables are valid.

 Boundary {
     type = "reflecting";
 }

 Domain {
     lower = [ 0.0, 0.0, 0.0];
     upper = [ 1.0, 1.0, 1.0];
 }

 Units {
    density = 1.6726219E-24;  # m_H in grams... so n = 1.0 cm^-3 for pure hydrogen
    time    = 3.15576E13;     # 1 Myr in seconds
    length  = 3.086E18;       # 1 pc in cm - does not actually matter
 }

 Field {
     alignment = 8;
     gamma = 1.400;
     ghost_depth = 3;
     list = [ "density", 
              "internal_energy",
              "total_energy",
              "velocity_x",
              "velocity_y",
              "velocity_z",
# purposefully commenting these out to test automatic
# creation of needed fields
#              "HI_density",
#              "HII_density",
              "HM_density",
              "HeI_density",
              "HeII_density",
              "HeIII_density",
              "H2I_density",
              "H2II_density",
              "DI_density",
              "DII_density",
              "HDI_density",
              "e_density",
              "metal_density",
              "cooling_time",  
              "temperature",
              "pressure",
              "gamma"
     ];

     padding = 0;
 }

 Group {
   list = ["color", "derived"];
   
   # fields that should be advected by hydro MUST be defined
   # as color here. This is handled automatically in 
   # EnzoMethodGrackle for the Grackle-specific fields (species)
   # but not everything
    color {
       field_list = [
# because the entries for the first 2 fields were purposefully commented out
# from Field::list, we need to comment them out here too (you can't add a
# non-existant field to a group). This is okay: when EnzoMethodGrackle creates
# these missing fields, it will automatically add them to the "color" group
#              "HI_density",
#              "HII_density",
              "HM_density",
              "HeI_density",
              "HeII_density",
              "HeIII_density",
              "H2I_density",
              "H2II_density",
              "DI_density",
              "DII_density",
              "HDI_density",
              "e_density",
              "metal_density",
              "cooling_time",
              "temperature",
              "pressure",
              "gamma" ];
    }

# derived fields grouping enables Enzo-E to ensure
#  that all derived fields are updated prior to output
#  In order for this to work, these MUST have their own
#  compute classes.
    derived {
        field_list = ["temperature",
                      "pressure",
                      "cooling_time"];
    }
 }

 Initial {
   list = ["one_zone_freefall_test"];
   one_zone_Freefall_test {
      # See note in "Mesh" on running in < 3D
      initial_density = 1.0;
      minimum_energy      = 10.0;
      maximum_energy      = 1000.0;
      minimum_metallicity      = 1e-6;
      maximum_metallicity      = 1e-2;
   }
 }

 Mesh {
     #   This test problem varies energy in the x direction 
     #   and metallicity in the y direction 
     root_blocks = [ 4, 4];
     root_rank = 2;
     root_size = [128, 128];
 }

 Method {
      list = [ "grackle", "null"];

     grackle {
        courant = 0.40; # meaningless unless use_cooling_timestep = true;

        data_file = "input/Grackle/CloudyData_UVB=HM2012_shielded.h5";

        with_radiative_cooling = 1;
        primordial_chemistry   = 2;  # 1, 2, or 3
        h2_on_dust             = 1;
        metal_cooling          = 1;  # 0 or 1 (off/on)
        UVbackground           = 0;  # on or off
        self_shielding_method  = 0;  # 0 - 3 (0 or 3 recommended)

        HydrogenFractionByMass = 0.73;

        # set this to true to limit the maximum timestep to the product of the
        # minimum cooling/heating time and courant.
        use_cooling_timestep = false; # default is false
     }

     # use this to limit maximum timestep if grackle::use_cooling_timestep is
     # set to false and Grackle crashes due to max iteration limit - this is
     # not needed generally in a real simulation as hydro timestep will
     # be small (usually)
     null { dt = 1.0; }

 }

 Output {
     list = ["data"];

     data {
         field_list = [ "density",
              "internal_energy",
              "total_energy",
              "velocity_x",
              "velocity_y",
              "velocity_z",
              "HI_density",
              "HII_density",
              "HM_density",
              "HeI_density",
              "HeII_density",
              "HeIII_density",
              "H2I_density",
              "H2II_density",
              "DI_density",
              "DII_density",
              "HDI_density",
              "e_density",
              "metal_density",
              "cooling_time",
              "temperature",
              "pressure",
              "gamma"
               ];

         dir   = ["ONE_ZONE_FREEFALL_TEST_%03d","cycle"];
         name = [ "method_grackle-1-%03d-%03d.h5","cycle", "proc" ];
         schedule {
             var = "time";
             step = 100.0;
             start = 0.0;
         }
         type = "data";
     }

 }

 Stopping {
    time = 100.0;
 }

