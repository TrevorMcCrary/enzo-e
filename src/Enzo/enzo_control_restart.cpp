// See LICENSE_CELLO file for license and copyright information

/// @file     enzo_control_restart.cpp
/// @author   James Bordner (jobordner@ucsd.edu)
/// @date     2022-03-10
/// @brief    Enzo-E portion of restart
/// @ingroup  Enzo
///
/// This file controls restarting from files generated by a previous call
/// to EnzoMethodCheck

//--------------------------------------------------

#include "enzo.hpp"

#include "charm_simulation.hpp"
#include "charm_mesh.hpp"
#include "main.hpp"

// #define TRACE

#ifdef TRACE
#   undef TRACE
#   define TRACE(MSG) \
  CkPrintf ("%d TRACE %s\n",CkMyPe(),std::string(MSG).c_str()); \
  fflush(stdout);
#   define TRACE_BLOCK(MSG,BLOCK)                                    \
  CkPrintf ("%d TRACE %s %s\n",CkMyPe(),BLOCK->name().c_str(), \
            std::string(MSG).c_str());                         \
  fflush(stdout);
#else
#   define TRACE(MSG)  /* ... */
#endif


//----------------------------------------------------------------------

void Block::restart_enter_()
{
  TRACE_BLOCK("restart_enter_",this);
  const std::string restart_dir  = cello::config()->initial_restart_dir;
  if (index_.is_root()) {
    proxy_simulation[0].p_restart_enter(restart_dir);
  }
}

//----------------------------------------------------------------------

void Simulation::p_restart_enter (std::string name_dir)
{
  // [ Called on root ip only ]

  // Create new empty IoEnzoReader chare array and distribute to other processing elements
  proxy_io_enzo_reader = CProxy_IoEnzoReader::ckNew();
  proxy_enzo_simulation.p_set_io_reader(proxy_io_enzo_reader);

  // Open and read the checkpoint file_list file
  std::ifstream stream_file_list = file_open_file_list_(name_dir);
  int num_files;
  stream_file_list >> num_files;

  sync_restart_done_.set_stop(num_files);

  // Insert an IoEnzoReader element for each file
  for (int i=0; i<num_files; i++) {
    std::string name_file;
    stream_file_list >> name_file;
    // Create ith io_reader to read name_file
    proxy_io_enzo_reader[i].insert(name_dir,name_file);
    CkPrintf ("TRACE_RESTART file %d %s\n",i,name_file.c_str());
  }

  proxy_io_enzo_reader.doneInserting();
}

//----------------------------------------------------------------------

IoEnzoReader::IoEnzoReader(std::string name_dir, std::string name_file) throw()
  : CBase_IoEnzoReader(),
    name_dir_(name_dir),
    name_file_(name_file),
    stream_block_list_()
{
  CkPrintf ("%d IoEnzoReader(%s,%s)\n",
            CkMyPe(),name_dir.c_str(),name_file.c_str());
  stream_block_list_ = open_block_list_(name_dir, name_file+".block_list");
  for (std::string block_name; read_block_list_(block_name);) {
    CkPrintf ("TRACE_RESTART IoEnzoReader %d %s\n",
              thisIndex,block_name.c_str());
  }
  close_block_list_();
  proxy_enzo_simulation[0].p_restart_done();
}
//----------------------------------------------------------------------

void EnzoSimulation::p_set_io_reader(CProxy_IoEnzoReader io_enzo_reader)
{
  proxy_io_enzo_reader = io_enzo_reader;
}

//----------------------------------------------------------------------

void EnzoSimulation::p_restart_done()
{
  TRACE("EnzoSimulation::p_restart_done");
  if (sync_restart_done_.next()) {
    enzo::block_array().p_restart_done();
  }
}

void EnzoBlock::p_restart_done()
{
  TRACE_BLOCK("EnzoBlock::p_restart_done()",this);
  adapt_exit_();
}

//======================================================================

std::ifstream Simulation::file_open_file_list_(std::string name_dir)
{
  std::string name_file = name_dir + "/check.file_list";

  std::ifstream stream_file_list (name_file);

  ASSERT1("Simulation::file_copen_file_list_",
          "Cannot open hierarchy file %s for writing",
          name_file.c_str(),stream_file_list);

  return stream_file_list;
}

//----------------------------------------------------------------------

std::ifstream IoEnzoReader::open_block_list_
(std::string name_dir, std::string name_file)
{
  std::string name_file_full = name_dir + "/" + name_file;

  std::ifstream stream_block_list (name_file_full);

  ASSERT1("Simulation::create_block_list_",
          "Cannot open block_list file %s for reading",
          name_file_full.c_str(),stream_block_list);

  return stream_block_list;
}

//----------------------------------------------------------------------

bool IoEnzoReader::read_block_list_(std::string & block_name)
{
  bool value (stream_block_list_ >> block_name);
  CkPrintf ("TRACE_RESTART read_block_list %s\n",block_name.c_str());
  return value;
}

//----------------------------------------------------------------------

void IoEnzoReader::close_block_list_()
{
}

// //----------------------------------------------------------------------

// void Block::restart_enter_()
// {
//   TRACE_ENZO_RESTART_BLOCK("restart_enter_",this);
//   const std::string restart_dir  = cello::config()->initial_restart_dir;
//   const std::string restart_file = cello::config()->initial_restart_file;
//   if (index_.is_root()) {
//     proxy_main.p_restart_enter(restart_dir,restart_file);
//   }
// }

// //----------------------------------------------------------------------

// void Main::p_restart_enter
// (std::string restart_dir, std::string restart_file)
// {
//   // open hierarchy file
//   TRACE_RESTART_MAIN("Main::restart_enter_ open hierarchy file");
//   CkPrintf ("DEBUG_RESTART restart_dir = %s\n",restart_dir.c_str());
//   CkPrintf ("DEBUG_RESTART restart_file = %s\n",restart_file.c_str());
//   // read hierarchy file
//   TRACE_RESTART_MAIN("Main::restart_enter_ read hierarchy file");
//   // create block_array
//   TRACE_RESTART_MAIN("Main::restart_enter_ create block array");
//   // create IoEnzoReader array
//   TRACE_RESTART_MAIN("Main::restart_enter_ create IoEnzoReader array");
//   // initialize sync_file(num_io_reader)
//   //  for (i_f = files in restart) {
//   //    io_reader[i_f].insert(file_block);
//   //  }
//   // close hierarcy file
//   TRACE_RESTART_MAIN("restart_enter_ close hierarchy file");
// }
